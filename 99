99
Поиск элементов с помощью XPath

В работе с веб-страницами не всегда получается найти селектор, однозначно описывающий путь к нужному элементу. В такой ситауции для тестировщика
лучшим решением проблемы будет пойти к фронтенд-разработчику проекта и договориться о специальном атрибуте, который будет использоваться в автотестах.
Таким образом можно повысить тестируемость приложения. Увы, проекты бывают разные, и не всегда это возможно. И когда другого выхода больше нет, а
автоматизировать как-то надо, можно обратиться к помощи языка запросов XPath.

На тему XPath мнения расходятся, но как бы то ни было, это мощный и гибкий инструмент, который позволяет писать сложные запросы для поиска
элементов.

Прежде всего, XPath (XML Path Language) это язык запросов, который использует древовидную структуру документа. Проверять XPath-запросы можно
точно так же как и CSS-селекторы - в консоли разработчика. Откройте консоль на странице с котиками, и давайте на её примере разберемся в
основах синтаксиса. Попробуйте вбить каждый из запросов-примеров в строку поиска, чтобы увидеть, что именно находит поисковый запрос.

1. XPath запрос всегда начинается с символа / или //
Символ / аналогичен символу > в CSS-селекторе, а символ // - пробелу. Их смысл:
- el1/e2 - выбирает элементы el2, являющиеся прямыми потомками el1;
- el1//e2 - выбирает элементы el2, являющиеся потомками el1 любой степени вложенности.

Разница состоит в том, что в XPath, когда мы начинаем запрос с символа /, мы должны указать элемент, являющийся корнем нашего документа.
Корнем всегда будет элемент с тегом <html>. Пример: /html/body/header

Мы можем начинать запрос и с символа //. Это будет означать, что мы хотим найти всех потомков корневого элемента без указания корневого элемента.
В этом случае, для поиска того же хедера, мы можем выполнить запрос //header, так как других заголовков у нас нет.

Важно! Такой поиск может быть неоднозначным. Например, запрос //div вернет вам все элементы с тегом <div>. Избегайте неоднозначных ситуаций,
они плохо влияют на здоровье ваших автотестов.

2. Символ [] - это команда фильтрации

Если по запросу найдено несколько элементов, то будет произведена фильтрация по правилу, указанному в скобках.

Правил фильтрации очень много:
- по любому атрибуту, будь то id, class, title (или любой другой). Например, мы хотим найти с летящим котом, для этого можно выполнить запрос
//img[@id='bullet']
- по порядковому номеру. Допустим, мы хотим выбрать вторую по порядку карточку с котом. Для этого найдем элемент с классом "row" и возьмем
его второго потомка: //div[@class="row"]/div[2]
- по полному совпадению текста. Да, XPath - это единственный способ найти элемент по внутреннему тексту. Если мы хотим найти блок текста с 
котом-Лениным, можно воспользоваться XPath селектором //p[text()="Lenin cat"]. Такой селектор вернет элемент, только если текст полностью
совпадает. Здесь важно сказать, что не всегда поиск по тексту - это хорошая практика, особенно в случае мультиязычных сайтов.
- по частичному совпадению текста или атрибута. Для этого нужна функция contains. Запрос //p[contains(text(), "cat")] вернет нам все абзацы
текста, которые содержат слово cat. Точно так же можно искать по частичному совпадению других атрибутов, это удобно, если у элемента 
несколько классов. Посмотрите на код навбара сайта с котами. Его можно найти селектором //div[contains(@class, "navbar")]
- в фильтрации еще можно использовать булевы операции (and, or, not) и некоторые
